COMPILER Tastier

/*
  First, let's declare all the types we're going to use.
*/

  enum TastierType : int {   // types for variables
    Undefined,
    Integer,
    Boolean,
    String,
    Character,
  };

  enum TastierKind : int {  // kinds of symbol
    Const,
    Var,
    Proc,
    ArrayVar,
    Record
  };

/*
  You'll notice some type aliases, such as the one just below, are commented
  out. This is because C# only allows using-alias-directives outside of a
  class, while class-inheritance directives are allowed inside. So the
  snippet immediately below is illegal in here. To complicate matters
  further, the C# runtime does not properly handle class-inheritance
  directives for Tuples (it forces you to write some useless methods). For
  these reasons, the type aliases which alias Tuples can be found in
  Parser.frame, but they're documented in this file, with the rest.
*/

  //using Symbol = System.Tuple<string, int, int, int, int>;

/*
  A Symbol is a name with a type and a kind. The first int in the
  tuple is the kind, and the second int is the type. We'll use these to
  represent declared names in the program.

  For each Symbol which is a variable, we have to allocate some storage, so
  the variable lives at some address in memory. The address of a variable on
  the stack at runtime has two components. The first component is which
  stack frame it's in, relative to the current procedure. If the variable is
  declared in the procedure that's currently executing, then it will be in
  that procedure's stack frame. If it's declared in the procedure that
  called the currently active one, then it'll be in the caller's stack
  frame, and so on. The first component is the offset that says how many
  frames up the chain of procedure calls to look for the variable. The
  second component is simply the location of the variable in the stack frame
  where it lives.

  The third int in the symbol is the stack frame on which the variable
  lives, and the fourth int is the index in that stack frame. Since
  variables which are declared in the global scope aren't inside any
  function, they don't have a stack frame to go into. In this compiler, our
  convention is to put these variables at an address in the data memory. If
  the variable was declared in the global scope, the fourth field in the
  Symbol will be zero, and we know that the next field is an address in
  global memory, not on the stack.

  Procedures, on the other hand, are just sets of instructions. A procedure
  is not data, so it isn't stored on the stack or in memory, but is just a
  particular part of the list of instructions in the program being run. If
  the symbol is the name of a procedure, we'll store a -1 in the address
  field (5).

  When the program is being run, the code will be loaded into the machine's
  instruction memory, and the procedure will have an address there. However,
  it's easier for us to just give the procedure a unique label, instead of
  remembering what address it lives at. The assembler will take care of
  converting the label into an address when it encounters a JMP, FJMP or
  CALL instruction with that label as a target.

  To summarize:
* Symbol.Item1 -> name
    * Symbol.Item2 -> kind
    * Symbol.Item3 -> type
    * Symbol.Item4 -> stack frame pointer
    * Symbol.Item5 -> variable's address in the stack frame pointed to by
                      Item4, -1 if procedure
*/

  class Scope : Stack<Symbol> {}

/*
  A scope contains a stack of symbol definitions. Every time we come across
  a new local variable declaration, we can just push it onto the stack. We'll
  use the position of the variable in the stack to represent its address in
  the stack frame of the procedure in which it is defined. In other words, the
  variable at the bottom of the stack goes at location 0 in the stack frame,
  the next variable at location 1, and so on.
*/

  //using Instruction = Tuple<string, string>;
  class Program : List<Instruction> {}

/*
  A program is just a list of instructions. When the program is loaded into
  the machine's instruction memory, the instructions will be laid out in the
  same order that they appear in this list. Because of this, we can use the
  location of an instruction in the list as its address in instruction memory.
  Labels are just names for particular locations in the list of instructions
  that make up the program.

  The first component of all instructions is a label, which can be empty.
  The second component is the actual instruction itself.

  To summarize:
    * Instruction.Item1 -> label
    * Instruction.Item2 -> the actual instruction, as a string
*/

Stack<Scope> openScopes = new Stack<Scope>();

Stack<Instruction> constDecls = new Stack<Instruction>(); 

/* 
  using ArrayDecl = System.Tuple<string, System.Collections.Generic.List<int>>;

  arraysList is a List of array declarations; name of array and lengths / dimensions of array
  e.g. exampleArray[2][3][3] 
       arraysList.Add(new ArrayDecl("exampleArray", List(2,3,3)))
*/

List<ArrayDecl> arraysList = new List<ArrayDecl>();

/* 
  using RecordDecl = System.Tuple<string, System.Collections.Generic.List<System.Tuple<string,int,int>>>;

  recDeclsList is a List of record declarations; name of record and details of record members
  e.g. record aRecord {
             Members;
       };
       recDeclsList.Add(new RecDecl("aRecord", List(members))) 
*/

List<RecordDecl> recDeclsList = new List<RecordDecl>();

/*
  using RecordInstance = System.Tuple<string, string>;

  recInstsList is a List of declared record instances. 
  e.g. record aRecord {
             Members;
       };

       record aRecord myRecord;
      recInstsList.Add(new RecordInstance(myRecord, aRecord);
*/

List<RecordInstance> recInstsList = new List<RecordInstance>();

/*
  using ParameterisedProc = System.Tuple<string, System.Collections.Generic.List<System.Tuple<string, int, int, int, int>>>;

  paramProcsList is a List of Parameterised Procedures. A field in the list contains the name of 
  the procedure and a list of its parameters (as symbols).
  e.g. void example(int a, string b[2][3]) {
          etc.
       }
      paramProcsList.Add(new ParameterisedProc(example, List(symbol(a),symbol(b))));
*/

List<ParameterisedProc> paramProcsList = new List<ParameterisedProc>();

public static string Reverse(string s) {
    char[] charArray = s.ToCharArray();
    Array.Reverse(charArray);
    return new string(charArray);
}

/*
  int nextFreeAddress = 0;
  Global counter that tracks where the next free address is memory is.
  Useful for strings and arrays. 

  E.g.
  if a string variable s is to be assigned, s := "hello world"
  The string "hello world" must be stored in memory. To assign this
  string to s, we store the address where the string starts in the 
  variable's address. Therefore acting like a pointer! As the length of
  the string is stored as the first address of the string, we then know how
  many addresses to read in when we want to load the variable s! 

  If say, another variable is declared in the program after this string is
  assigned, we know where the next free address is because we incremented the
  counter for each character of the string, we store this new variable at this
  address without fear of overwriting the string.
*/
int nextFreeAddress = 0; 

/*
  Every time we encounter a new procedure declaration in the program, we want
  to make sure that expressions inside the procedure see all of the variables
  that were in scope at the point where the procedure was defined. We also
  want to make sure that expressions outside the procedure do not see the
  procedure's local variables. Every time we encounter a procedure, we'll push
  a new scope on the stack of open scopes. When the procedure ends, we can pop
  it off and continue, knowing that the local variables defined in the
  procedure cannot be seen outside, since we've popped the scope which
  contains them off the stack.
*/

Program program = new Program();
Program header = new Program();

Stack<string> openProcedureDeclarations = new Stack<string>();

/*
  In order to implement the "shadowing" of global procedures by local procedures
  properly, we need to generate a label for local procedures that is different
  from the label given to procedures of the same name in outer scopes. See the
  test case program "procedure-label-shadowing.TAS" for an example of why this
  is important. In order to make labels unique, when we encounter a non-global
  procedure declaration called "foo" (for example), we'll give it the label
  "enclosingProcedureName$foo" for all enclosing procedures. So if it's at
  nesting level 2, it'll get the label "outermost$nextoutermost$foo". Let's
  make a function that does this label generation given the set of open
  procedures which enclose some new procedure name.
*/

string generateProcedureName(string name) {
  if (openProcedureDeclarations.Count == 0) {
    return name;
  } else {
    string temp = name;
    foreach (string s in openProcedureDeclarations) {
      temp = s + "$" + temp;
    }
    return temp;
  }
}

/*
  We also need a function that figures out, when we call a procedure from some
  scope, what label to call. This is where we actually implement the shadowing;
  the innermost procedure with that name should be called, so we have to figure
  out what the label for that procedure is.
*/

string getLabelForProcedureName(int lexicalLevelDifference, string name) {
  /*
     We want to skip <lexicalLevelDifference> labels backwards, but compose
     a label that incorporates the names of all the enclosing procedures up
     to that point. A lexical level difference of zero indicates a procedure
     defined in the current scope; a difference of 1 indicates a procedure
     defined in the enclosing scope, and so on.
  */
  int numOpenProcedures = openProcedureDeclarations.Count;
  int numNamesToUse = (numOpenProcedures - lexicalLevelDifference);
  string theLabel = name;

  /*
    We need to concatenate the first <numNamesToUse> labels with a "$" to
    get the name of the label we need to call.
  */

  var names = openProcedureDeclarations.Take(numNamesToUse);

  foreach (string s in names) {
      theLabel = s + "$" + theLabel;
  }

  return theLabel;
}

Stack<string> openLabels = new Stack<string>();
int labelSeed = 0;

string generateLabel() {
  return "L$"+labelSeed++;
}

/*
  Sometimes, we need to jump over a block of code which we're about to
  generate (for example, at the start of a loop, if the test fails, we have
  to jump to the end of the loop). Because it hasn't been generated yet, we
  don't know how long it will be (in the case of the loop, we don't know how
  many instructions will be in the loop body until we actually generate the
  code, and count them). In this case, we can make up a new label for "the
  end of the loop" and emit a jump to that label. When we get to the end of
  the loop, we can put the label in, so that the jump will go to the
  labelled location. Since we can have loops within loops, we need to keep
  track of which label is the one that we are currently trying to jump to,
  and we need to make sure they go in the right order. We'll use a stack to
  store the labels for all of the forward jumps which are active. Every time
  we need to do a forward jump, we'll generate a label, emit a jump to that
  label, and push it on the stack. When we get to the end of the loop, we'll
  put the label in, and pop it off the stack.
*/

Symbol lookup(Stack<Scope> scopes, string name) {
  int stackFrameOffset = 0;
  int variableOffset = 0;

  foreach (Scope scope in scopes) {
    foreach (Symbol s in scope) {
      if (s.Item1 == name) {
        return s;
      }
      else {
        variableOffset += 1;
      }
    }
    stackFrameOffset += 1;
    variableOffset = 0;
  }
  return null; // if the name wasn't found in any open scopes.
}

/*
  You may notice that when we use a LoadG or StoG instruction, we add 3 to
  the address of the item being loaded or stored. This is because the
  control and status registers of the machine are mapped in at addresses 0,
  1, and 2 in data memory, so we cannot use those locations for storing
  variables. If you want to load rtp, rbp, or rpc onto the stack to
  manipulate them, you can LoadG and StoG to those locations.
*/

/*--------------------------------------------------------------------------*/

CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  dot = '.'.
  space = '\u0020'.
  chars = ANY - cr - lf - '\''.
  stringchars = ANY - cr - lf - '\"'.

TOKENS
  ident  = letter {letter | dot | digit}.
  number = digit {digit}.
  string = '"' {stringchars} '"'.
  char = '\'' [chars]'\''.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*------------------------------------------------------------------------*/

AddOp<out Instruction inst>
=                               (.  inst = new Instruction("", "Add"); .)
  ( '+'
  | '-'                         (.  inst = new Instruction("", "Sub"); .)
  ).

/*------------------------------------------------------------------------*/

Expr<out TastierType type>      (.  TastierType type1; Instruction inst; .)
= SimExpr<out type>
  [ RelOp<out inst>
    SimExpr<out type1>          (.
                                    if (type != type1) { SemErr("incompatible types");
                                    } else { program.Add(inst); type = TastierType.Boolean; }
                                .)
      ['?'                      (.
                                    if (type != TastierType.Boolean) SemErr("boolean type expected");
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                                .)
      Expr<out type>            (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop");
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    program.Add(startOfElse);
                                .)              
      ':'
      Expr<out type1>           (.  if (type != type1) { SemErr("<expr1>:<expr2> of different types");
                                    } else { program.Add(new Instruction(openLabels.Pop(), "Nop")); }
                                .)
      ]
  ].

/*------------------------------------------------------------------------*/
/*
  aString is used when a string is to be stored in memory.
  Strings are stored in data memory.

  e.g. string s;  //address 3
       string st; //address 4

       s := "hello world"
       
       The variable s is at address 3.

       When s is to be assigned with a string e.g. "hello world":
       The length of the string is stored at the next free address in memory, 
       e.g. 11 at address 5. The string is reversed and each character is stored 
       individually in memory.. 6, 7, 8... Finally, the starting address of the 
       string is stored in the variable address. So, address 3 will hold the 
       value 5 (like a pointer). From this address, the length of the string is 
       found (11) and we know how many memory addresses to load to load 
       the entire string.
*/

aString                     (.  int len = 0; .)
= string                        (.
                                  foreach(char c in t.val) {
                                    if(c != '"') len = len + 1;
                                  }

                                  int stringStartAddress = nextFreeAddress;
                                  program.Add(new Instruction("", "Const " + len));
                                  program.Add(new Instruction("", "StoG " + (nextFreeAddress + 3)));
                                  nextFreeAddress = nextFreeAddress + 1;
                                  string rev = Reverse(t.val);

                                  foreach(char c in rev) {
                                    if(c != '"') {
                                      program.Add(new Instruction("", "Const " + Convert.ToInt32(c)));
                                      program.Add(new Instruction("", "StoG " + (nextFreeAddress + 3)));
                                      nextFreeAddress = nextFreeAddress + 1;
                                    }
                                  }
                                  program.Add(new Instruction("", "Const " + (stringStartAddress + 3)));
                                .)
.

/*------------------------------------------------------------------------*/
/*
  loadStoArrayIndex<bool store, Symbol sym> is called when we want to load 
  or store an array element.

  e.g. array[1][2] := 6; i := array[1][2]; write array[3][2][1]; etc.

  It takes a Boolean value ‘store’ which is given as true or false
  depending on whether we want to load or store an array address. It also 
  takes the Symbol that represents the array, supplied by the caller; 
  Stat or Factor.

*/
loadStoArrayIndex
<bool store, Symbol sym>        (.  List<int> indexes = new List<int>(); ArrayDecl temp = null; int n, arrLen = 1; 
                                    TastierType type;
                                .)
=                               //Each number represents the index address of a dimension. 
   '[' number                   (.  n = Convert.ToInt32(t.val); indexes.Add(n); .)    
    ']'     
    { '[' number                (.  n = Convert.ToInt32(t.val); indexes.Add(n); .)    
      ']'
    }                           /*
                                  1. Make sure it is a declared array that is being indexed
                                  2. Ensure all indexes are within bounds of dimensions
                                  3. Calculate the offset: ((index i * dimension i+1) + index i+1) * dimension i+2 etc..
                                  4. Make sure offset is within array bounds
                                  5. Load or Store

                                */
                                (.  if((TastierKind)sym.Item2 != TastierKind.ArrayVar) SemErr ("cannot index into non-array");

                                    foreach (ArrayDecl a in arraysList) {
                                      if((a.Item1).Equals(sym.Item1)){ temp = a; break; }
                                    }

                                    if (temp.Item2.Count != indexes.Count ) SemErr("cannot convert from "+indexes.Count+"D to "+temp.Item2.Count+"D");

                                    for (int i = 0; i < temp.Item2.Count; i++) {
                                      if ((temp.Item2[i] - indexes[i]) < 1) SemErr("array out of bounds exception: " + indexes[i]);
                                        arrLen = arrLen * temp.Item2[i];
                                    }

                                    int offset = indexes[0];
                                    for (int i = 1; i < temp.Item2.Count; i++) {
                                      offset = offset * temp.Item2[i];
                                      offset = offset + indexes[i];
                                    }

                                    if (offset > arrLen) SemErr("array out of bounds exception: " + offset);
                                .)
    ( ":="                      (.  if (store == false) SemErr("syntax error '='"); .) 
      Expr<out type>            (.  program.Add(new Instruction("", "StoG " + ((sym.Item5 + 3) + offset))); .)
      ';'
    |                           (.  program.Add(new Instruction("", "LoadG " + ((sym.Item5 + 3) + offset))); .)  
    )                         
.

/*------------------------------------------------------------------------*/

Factor<out TastierType type>    (.  Symbol sym; string name; bool store = false; .)
=                               (.  type = TastierType.Undefined; .)
  ( Ident<out name>             (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) SemErr("reference to undefined variable " + name);
                                .)
    ( loadStoArrayIndex         //A single array index to be loaded e.g. i := myArray[3][2][0];
      <store, sym>
    |                           (.  if ((TastierKind)sym.Item2 != TastierKind.Var && (TastierKind)sym.Item2 != TastierKind.Const) 
                                      SemErr ("variable expected");
                                    if (sym.Item4 == 0) {
                                      program.Add(new Instruction("", "LoadG " + (sym.Item5+3)));
                                    } else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Load " + lexicalLevelDifference + " " + sym.Item5));
                                    }
                                .)
    )    
                                (.  type = (TastierType)sym.Item3; .)
  | number                      (.
                                    int n = Convert.ToInt32(t.val);
                                    program.Add(new Instruction("", "Const " + n));
                                    type = TastierType.Integer;
                                .)
  | aString                 (.  type = TastierType.String; .)
  | char                        (.  foreach(char c in t.val) {
                                      if(c != '\'') program.Add(new Instruction("", "Const " + Convert.ToInt32(c)));
                                    }
                                    type = TastierType.Character;
                                .)
  | '-'
    Factor<out type>            (.  
                                    if (type != TastierType.Integer) {
                                      SemErr("integer type expected");
                                      type = TastierType.Integer;
                                    }
                                    program.Add(new Instruction("", "Neg"));
                                    program.Add(new Instruction("", "Const 1"));
                                    program.Add(new Instruction("", "Add"));
                                .)
  | "true"                      (.  program.Add(new Instruction("", "Const " + 1)); type = TastierType.Boolean; .)
  | "false"                     (.  program.Add(new Instruction("", "Const " + 0)); type = TastierType.Boolean; .)
  ).

/*------------------------------------------------------------------------*/

Ident<out string name>
= ident                         (.  name = t.val; .).

/*------------------------------------------------------------------------*/

MulOp<out Instruction inst>
=                               (.  inst = new Instruction("", "Mul"); .)
  ( '*'
  | '/'                         (.  inst = new Instruction("", "Div"); .)
  ).

/*------------------------------------------------------------------------*/

ProcDecl                        (.  string name; string label; Scope currentScope = openScopes.Peek(); int enterInstLocation = 0; .)
= "void"
  Ident<out name>               (.
                                    currentScope.Push(new Symbol(name, (int)TastierKind.Proc, (int)TastierType.Undefined, openScopes.Count, -1));
                                    openScopes.Push(new Scope());
                                    currentScope = openScopes.Peek();
                                .)
  '(' { ParamDecl<name>         
        { ',' ParamDecl<name> } // 0 or N parameters in Procedure (Extra Feature)
      } 
  ')'
  '{'                           (.
                                    program.Add(new Instruction("", "Enter 0"));
                                    enterInstLocation = program.Count - 1;
                                    label = generateProcedureName(name);
                                    openProcedureDeclarations.Push(name);
                                    /*
                                      Enter is supposed to have as an
                                      argument the next free address on the
                                      stack, but until we know how many
                                      local variables are in this procedure,
                                      we don't know what that is. We'll keep
                                      track of where we put the Enter
                                      instruction in the program so that
                                      later, when we know how many spaces on
                                      the stack have been allocated, we can
                                      put the right value in.
                                    */
                        				    if(name == "Main") {
                        				       foreach(Instruction s in constDecls) {
                        				          program.Add(s);
                        				       }
                        				    }	 	
                                .)
  { VarDecl | Stat |  (.
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    /*
                                      We need to jump over procedure
                                      definitions because otherwise we'll
                                      execute all the code inside them!
                                      Procedures should only be entered via
                                      a Call instruction.
                                    */
                                .)
    ProcDecl                    (. program.Add(new Instruction(openLabels.Pop(), "Nop")); .)
  } '}'                         (.
                                    program.Add(new Instruction("", "Leave"));
                                    program.Add(new Instruction("", "Ret"));
                                    openScopes.Pop();
                                    // now we can generate the Enter instruction properly
                                    program[enterInstLocation] =
                                      new Instruction(label, "Enter " + currentScope.Count(s => s.Item2 == (int)TastierKind.Var));
                                    openProcedureDeclarations.Pop();
                                .).

/*------------------------------------------------------------------------*/

RelOp<out Instruction inst>
=                               
  ( '='                         (.  inst = new Instruction("", "Equ"); .)
  | '<'                         (.  inst = new Instruction("", "Lss"); .)
  | '>'                         (.  inst = new Instruction("", "Gtr"); .)
  | ">="			                  (.  inst = new Instruction("", "GtrOrEqu"); .)
  | "<="                        (.  inst = new Instruction("", "LssOrEqu"); .)
  | "!="                        (.  inst = new Instruction("", "NotEqu"); .)
  ).

/*------------------------------------------------------------------------*/

SimExpr<out TastierType type>   (.  TastierType type1; Instruction inst; .)
= Term<out type>
  { AddOp<out inst>
    Term<out type1>             (.
                                    if (type != TastierType.Integer || type1 != TastierType.Integer) {
                                      SemErr("integer type expected");
                                    }
                                    program.Add(inst);
                                .)
  }.

/*------------------------------------------------------------------------*/
/*
  Parameter is called from ProcedureCall. It is passed the parameter symbol.
  E.g. void myProcedure(int a, Record Tag aTag){
          ...
       }

  A procedure call is of the form e.g. myProcedure(17, singleTag);
                                       myProcedure(i, singleTag);
                                       etc.

  ProcedureCall passes the procedure parameter (variable taking value(s): a, aTag)
  Parameter<Symbol tempSym1> then executes instructions depending on whether the
  attribute (variable giving value(s): 17, i, singleTag) is an ident (i), a specific 
  array address (arr[1][1]), an array ident (arr), a record, a number (17), a 
  character, a string, "true" or "false". An integer variable / integer array 
  element / number could be passed as a minus value.

  An attribute being passed must be of the same type as the expecting parameter.

*/

Parameter<Symbol tempSym1>      (.  string name1, recAttr = "", recParam = ""; bool minus = false, store = false; int arrLen = 1; 
                                    List<int> attrLengths = new List<int>(); List<int> paramLengths = new List<int>();
                                    Symbol tempSym; List<RecordDeclMember> recDeclVars = new List<RecordDeclMember>(); 
                                .)
= (                           
    ['-'                        (.  minus = true; .)
    ]                         
    Ident<out name1>            (.  
                                    tempSym = lookup(openScopes, name1);
                                    if (tempSym == null) SemErr("reference to undefined constant or variable " + name1);
                                    if ((TastierKind)tempSym.Item2 != TastierKind.Proc && (TastierKind)tempSym.Item2 != TastierKind.ArrayVar
                                         && (TastierKind)tempSym.Item2 != TastierKind.Record) SemErr("attribute must be a variable"); 

                                    if ((int)tempSym.Item3 != (int)tempSym1.Item3) SemErr ("invalid procedure call, incompatible types");
                                    if ((minus == true) && ((int)tempSym.Item3 != (int)TastierType.Integer)) SemErr ("invalid procedure call, integer expected");
                                .)
      ( loadStoArrayIndex       
        <store, tempSym>        /*
                                  Passing a single array address.
                                  If the array is of type integer,
                                  a single negated element can be passed.
                                  I.e. myProcedure(array[1][2][1]);
                                       myProcedure(-myRecord.array[1][2][1]);
                                */
                                (.  if (minus == true) {
                                      program.Add(new Instruction("", "Neg"));
                                      program.Add(new Instruction("", "Const 1"));
                                      program.Add(new Instruction("", "Add"));
                                    }
                                    program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                .)  
      |                         (.  
                                  if (tempSym.Item4 == 0) {
                                      if ((TastierKind)tempSym.Item2 == TastierKind.ArrayVar) {
                                        /*
                                        If an entire array is to be passed,
                                        the expecting parameter must also be 
                                        an array of the same dimensions and 
                                        length. Every address in the supplying
                                        attribute must be copied to the expecting
                                        parameter.
                                      */
                                        if ((minus == true) && ((TastierKind)tempSym.Item2 == TastierKind.ArrayVar)) SemErr("syntax error: '-'");
                                        foreach (ArrayDecl a in arraysList) {
                                          if((a.Item1).Equals(name1)) { attrLengths = a.Item2; break; }
                                        }
                                        foreach (ArrayDecl a in arraysList) {
                                          if((a.Item1).Equals(tempSym1.Item1)) { paramLengths = a.Item2; break; }
                                        }

                                        if ((attrLengths).SequenceEqual(paramLengths)) {
                                          for (int j = 0; j < attrLengths.Count; j++) arrLen = arrLen * attrLengths[j];
                                        } else { SemErr ("incompatible array attribute"); }

                                        for (int k = 0; k < arrLen; k++) {
                                          program.Add(new Instruction("", "LoadG " + (tempSym.Item5+3+k)));
                                          program.Add(new Instruction("", "StoG " + (tempSym1.Item5+3+k)));
                                        }
                                      } else if ((TastierKind)tempSym.Item2 == TastierKind.Record) {
                                        /*
                                        If a record is to be passed, the passing
                                        and receiving records must be instances
                                        of the same record declaration. Each value
                                        for each member of the record being passed
                                        must be passed to each member of the record
                                        receiving.
                                      */
                                        int l = 1;
                                        foreach (RecordInstance r in recInstsList) {
                                          if((r.Item1).Equals(name1)) { recAttr = r.Item2; break; }
                                        }
                                        foreach (RecordInstance r in recInstsList) {
                                          if((r.Item1).Equals(tempSym1.Item1)) { recParam = r.Item2; break; }
                                        }
                                        if(recAttr.Equals(recParam)) {
                                          foreach (RecordDecl r in recDeclsList) {
                                            if((r.Item1).Equals(recAttr)) { recDeclVars = r.Item2; break; }
                                          }
                                          foreach (RecordDeclMember r in recDeclVars) {
                                            if (r.Item3 == -1) {
                                              program.Add(new Instruction("", "LoadG " + (tempSym.Item5+3+l)));
                                              program.Add(new Instruction("", "StoG " + (tempSym1.Item5+3+l)));
                                            } else { //array member
                                              for(int m = 0; m < r.Item3; m++) {
                                                program.Add(new Instruction("", "LoadG " + (tempSym.Item5+3+m)));
                                                program.Add(new Instruction("", "StoG " + (tempSym1.Item5+3+m)));
                                              }
                                            }
                                            l = l + 1;
                                          }
                                        }
                                      } else {
                                        /* global variable or string being passed. */
                                        program.Add(new Instruction("", "LoadG " + (tempSym.Item5 + 3)));
                                        if (minus == true) {
                                          program.Add(new Instruction("", "Neg"));
                                          program.Add(new Instruction("", "Const 1"));
                                          program.Add(new Instruction("", "Add"));
                                        }
                                        program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                      }
                                    } else {
                                      /* local integer / boolean / character variable being passed. */
                                      int lexicalLevelDifferencetempSym = Math.Abs(openScopes.Count - tempSym.Item4)-1;
                                      program.Add(new Instruction("", "Load " + lexicalLevelDifferencetempSym + " " + tempSym.Item5));
                                      if (minus == true) {
                                        program.Add(new Instruction("", "Neg"));
                                        program.Add(new Instruction("", "Const 1"));
                                        program.Add(new Instruction("", "Add"));
                                      }
                                      program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                    } 
                                    minus = false; 
                                .)
      )
    | number                    (.  /* myProcedure(int i) {
                                         ...
                                       }
                                       ...
                                       myProcedure(78);
                                       myProcedure(-12);
                                    */
                                    if ((int)tempSym1.Item3 != (int)TastierType.Integer) SemErr ("invalid procedure call, incompatible types");
                                    int n = Convert.ToInt32(t.val);
                                    program.Add(new Instruction("", "Const " + n));
                                    program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                .)
    | '-' number                (.  
                                    if ((int)tempSym1.Item3 != (int)TastierType.Integer) SemErr ("invalid procedure call, incompatible types");
                                    int n = Convert.ToInt32(t.val);
                                    program.Add(new Instruction("", "Const " + n));
                                    program.Add(new Instruction("", "Neg"));
                                    program.Add(new Instruction("", "Const 1"));
                                    program.Add(new Instruction("", "Add"));
                                    program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                .)
    | char                      (.
                                    if ((int)tempSym1.Item3 != (int)TastierType.Character) SemErr ("invalid procedure call, incompatible types");
                                    foreach(char c in t.val) {
                                      if(c != '\'') program.Add(new Instruction("", "Const " + Convert.ToInt32(c)));
                                    }
                                    program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                .)
    | aString               (.
                                    if ((int)tempSym1.Item3 != (int)TastierType.String) SemErr ("invalid procedure call, incompatible types"); 
                                    program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                .)
    | "true"                    (.  
                                    if ((int)tempSym1.Item3 != (int)TastierType.Boolean) SemErr ("invalid procedure call, incompatible types");
                                    program.Add(new Instruction("", "Const " + 1));
                                    program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                .)
    | "false"                   (.  
                                    if ((int)tempSym1.Item3 != (int)TastierType.Boolean) SemErr ("invalid procedure call, incompatible types");
                                    program.Add(new Instruction("", "Const " + 0));
                                    program.Add(new Instruction("", "StoG " + (tempSym1.Item5 + 3)));
                                .)
    ) .  

/*------------------------------------------------------------------------*/ 
/*
  ProcedureCall is entered, as expected, when a call to a procedure is made.
  e.g. myProcedure(a, b, c);

  If the procedure was declared with parameters, its name and parameters
  would have been stored in the list of Parameterised Procedures.
  For each parameter in the procedure declaration, 'Paramater' is called
  which matches the attribute being passed to the parameter receiving.

  If a procedure was declared with for example, two parameters of type int 
  and record. A call to this procedure MUST include two attributes of type
  int and record, in this order.
*/                   

ProcedureCall<Symbol sym>       (.  int i = 0, numParams = 0;
                                    Symbol tempSym1 = null; List<Symbol> tempSymList = new List<Symbol>(); 
                                .)
=
  '('                           (.  
                                    if ((TastierKind)sym.Item2 != TastierKind.Proc) SemErr("object is not a procedure"); 

                                    foreach (ParameterisedProc p in paramProcsList) {
                                      if((p.Item1).Equals(sym.Item1)) {
                                        tempSymList = p.Item2; numParams = tempSymList.Count; break;
                                      }
                                    } 
                                .)
  [                             (.  tempSym1 = tempSymList[i]; .)
    Parameter<tempSym1>         (.  i = i + 1; .)

      {','                      (.  tempSym1 = tempSymList[i]; .)
        Parameter<tempSym1>     (.  i = i + 1; .)
      }
  ]                     
                                (.  
                                  if(numParams != 0) {
                                    if(i != numParams) SemErr("invalid procedure call, procedure takes " + numParams + " parameters");
                                  }
                                .)
    ')' ';'                 (.   
                                int currentStackLevel = openScopes.Count;
                                int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4);
                                string procedureLabel = getLabelForProcedureName(lexicalLevelDifference, sym.Item1);
                                program.Add(new Instruction("", "Call " + lexicalLevelDifference + " " + procedureLabel));
                            .)
.

/*------------------------------------------------------------------------*/

Stat                            (.  TastierType type, type1; string name; Symbol sym; bool store = true;.)

= Ident<out name>               (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) SemErr("reference to undefined constant or variable " + name); 
                                .)
  ( ( loadStoArrayIndex         //A single array index to be assigned e.g. myArray[3][2][0] := "banana";
      <store, sym>
    | ":="                            
      Expr<out type>            (.  if ((TastierKind)sym.Item2 != TastierKind.Var) SemErr ("variable expected");
                                    if (sym.Item4 == 0) {
                                      program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                    } else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
                                .)
      ';'
    )                                            
  | ProcedureCall<sym>
  )

| "if"
  '(' Expr<out type> ')'        (.
                                    if ((TastierType)type != TastierType.Boolean) SemErr("boolean type expected");
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                                .)
      Stat                      (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop");
                                     /*
                                        If we got into the "if", we need to
                                        jump over the "else" so that it
                                        doesn't get executed.
                                     */
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    program.Add(startOfElse);
                                 .)
      [ "else"
        Stat
      ]				                  (.  program.Add(new Instruction(openLabels.Pop(), "Nop")); .)

| "while"                       (.  string loopStartLabel = generateLabel();
                                    openLabels.Push(generateLabel()); //second label is for the loop end
                                    program.Add(new Instruction(loopStartLabel, "Nop"));
                                .)
  '(' Expr<out type> ')'        (.
                                    if ((TastierType)type != TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek())); // jump to the loop end label if condition is false
                                .)
      Stat                      (.  program.Add(new Instruction("", "Jmp " + loopStartLabel));
                                    program.Add(new Instruction(openLabels.Pop(), "Nop")); // put the loop end label here
                                .)

| "for" '('			                (.  List<Instruction> actions = new List<Instruction>(); int start; .)

    Ident<out name>             (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) SemErr("reference to undefined constant or variable " + name);
                                .)
    ":="                        
    Expr<out type>              (.  
                                    if ((((TastierKind)sym.Item2 != TastierKind.Var) && ((TastierKind)sym.Item2 != TastierKind.ArrayVar)))  
                                      SemErr("cannot assign to non-variable");
                                    if ((type != (TastierType)sym.Item3)) SemErr("incompatible types");		

                                    if (sym.Item4 == 0) {
                                        program.Add(new Instruction("", "StoG " + (sym.Item5 + 3) ));
                                    } else {
                                        int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                        program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
	
				                            string loopStartLabel = generateLabel();
                                    openLabels.Push(generateLabel()); //second label is for the loop end
                                    program.Add(new Instruction(loopStartLabel, "Nop"));
                                .)
    ';'
    Expr<out type>   		        (.  if ((TastierType)type != TastierType.Boolean) SemErr("boolean type expected"); .)
    ';'                         (.
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek())); // jump to the loop end label if condition is false
				                            start = program.Count;
                                .)
    Ident<out name>             (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) SemErr("reference to undefined constant or variable " + name);
                                .)
    ":="
    Expr<out type>		          (.
				                            if ((((TastierKind)sym.Item2 != TastierKind.Var) && ((TastierKind)sym.Item2 != TastierKind.ArrayVar))) 
                                      SemErr("cannot assign to non-variable");
                                    if ((type != (TastierType)sym.Item3)) SemErr("incompatible types");

				                            if (sym.Item4 == 0) {
                                        program.Add(new Instruction("", "StoG " + (sym.Item5 + 3) ));
                                    } else {
                                        int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                        program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }

				                            while(start < program.Count){
                                      actions.Add(program[start]);
                                      program.RemoveAt(start);
                                    }
				                        .)	   	
   ')'				
   '{' {Stat}	'}'  		          (.  foreach(Instruction i in actions) program.Add(i); 
                                    program.Add(new Instruction("", "Jmp " + loopStartLabel));
                                    program.Add(new Instruction(openLabels.Pop(), "Nop")); // put the loop end label here
                                .)

|"switch"
 '(' Expr<out type> ')' '{'     (.  openLabels.Push(generateLabel()); .)
 {
  "case" Expr<out type1> ':'    (.  if (type != type1) SemErr("conflicting types");
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Equ")); //check for equality between the switch and case variable
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek())); //jump if not equal
                                .)
  Stat
  "break" ';'                   (.
                                    string temp = openLabels.Pop();
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek())); //jump if case proved true, skip other cases
                                    program.Add(new Instruction(temp, "Nop"));
                                .)
 }
  "default" ':' Stat '}'        (.  program.Add(new Instruction(openLabels.Pop(), "Nop")); .) //case end label

| "read"
  Ident<out name> ';'           (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) SemErr("reference to undefined variable " + name);

                                    if (sym.Item2 != (int)TastierKind.Var) {
                                      SemErr("variable type expected but " + sym.Item1 + " has kind " + (TastierType)sym.Item2);
                                    }

                                    if (sym.Item3 != (int)TastierType.Integer) {
                                      SemErr("integer type expected but " + sym.Item1 + " has type " + (TastierType)sym.Item2);
                                    }
                                    program.Add(new Instruction("", "Read"));

                                    if (sym.Item4 == 0) {
                                      program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                    } else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
                                 .)

| "write"
   Expr<out type>               (.
                        				  if (type == TastierType.Integer) {
                                    program.Add(new Instruction("", "WriteInt"));
                                  } else if (type == TastierType.String) {
                                    program.Add(new Instruction("", "WriteStr"));  
                        				  } else if (type == TastierType.Boolean) {
                                    program.Add(new Instruction("", "WriteBool"));
                                  } else if (type == TastierType.Character) {
                                    program.Add(new Instruction("", "WriteChar"));
                                  } else {
                                    SemErr("integer / string / boolean / character type expected");
                                  }
                                .)
   { ',' Expr<out type>		      (.
				                          if (type == TastierType.Integer) {
                                    program.Add(new Instruction("", "WriteInt"));
                                  } else if (type == TastierType.String) {
                                    program.Add(new Instruction("", "WriteStr"));  
                                  } else if (type == TastierType.Boolean) {
                                    program.Add(new Instruction("", "WriteBool"));
                                  } else if (type == TastierType.Character) {
                                    program.Add(new Instruction("", "WriteChar"));
                                  } else {
                                    SemErr("integer / string / boolean / character type expected");
                                  }
				                        .)
   } ';'
| '{' { Stat | VarDecl } '}' .

/*------------------------------------------------------------------------*/

Tastier                         (.  string name; .)
= "program"
  Ident<out name>               (.
                                    openScopes.Push(new Scope());
                                .)
  '{'
    /*
      Record Declarations first in the program followed by
      Constant Declaration before Variables & Procedures.
    */
    { RecordDecl }  
    [ ConstDecl ]     
    { VarDecl | ProcDecl }
  '}'                           (.
                                    if (openScopes.Peek().Count == 0) {
                                      Warn("Warning: Program " + name + " is empty ");
                                    }

                                    header.Add(new Instruction("", ".names " + openScopes.Peek().Count));
                                    foreach (Symbol s in openScopes.Peek()) {
                                      if (s.Item2 == (int)TastierKind.Record) {
                                        header.Add(new Instruction("", ".record " + ((int)s.Item3) + " " + s.Item1));
					                            } else if (s.Item2 == (int)TastierKind.Const) {
					                           header.Add(new Instruction("", ".const " + ((int)s.Item3) + " " + s.Item1));
                                      } else if (s.Item2 == (int)TastierKind.Var) {
                                        header.Add(new Instruction("", ".var " + ((int)s.Item3) + " " + s.Item1));
                                      } else if (s.Item2 == (int)TastierKind.Proc) {
					                            header.Add(new Instruction("", ".proc " + s.Item1));
                                      } else {
                                        SemErr("global item " + s.Item1 + " has no defined type");
                                      }
                                    }
                                    
                                    header.AddRange(program);
                                    openScopes.Pop();
                                .).

/*------------------------------------------------------------------------*/

Term<out TastierType type>      (.  TastierType type1; Instruction inst; .)
= Factor<out type>
  { MulOp<out inst>
    Factor<out type1>           (.
                                    if (type != TastierType.Integer || type1 != TastierType.Integer) {
                                      SemErr("integer type expected");
                                    }
                                    program.Add(inst);
                                .)
  }.

/*------------------------------------------------------------------------*/

Type<out TastierType type>
=                               (.  type = TastierType.Undefined; .)
 ( "int"                        (.  type = TastierType.Integer; .)
 | "bool"                       (.  type = TastierType.Boolean; .)
 | "string"                     (.  type = TastierType.String; .)
 | "char"                       (.  type = TastierType.Character; .)
 ).

/*------------------------------------------------------------------------*/

ConstDecl
= "const"
  {
  ConstList
  }.

/*------------------------------------------------------------------------*/

ConstList                       (.  string name; Scope currentScope = openScopes.Peek();.)
=  Ident<out name>
                                
  ":="			        
  number 			                  (.  currentScope.Push(new Symbol(name, (int)TastierKind.Const, (int)TastierType.Integer,openScopes.Count-1, nextFreeAddress));
				                            int n = Convert.ToInt32(t.val);
				                            constDecls.Push(new Instruction("", "StoG " + (nextFreeAddress+3)));
                                    constDecls.Push(new Instruction("", "Const " + n));
				                            nextFreeAddress = nextFreeAddress + 1;
				                        .)
  ';'.
/*------------------------------------------------------------------------*/
/*
  Record Declarations exist only at the beginning of a program.
  All record declarations are stored in a list. Each Record declaration in that
  list is comprised of <the name of the record decl, List of its members>.  
  e.g. record aRecord {
              int a;
              string b;
              int c[3][2];
              };

  recDeclsList.Add(new RecDecl("aRecord", List(members)))
  Each Member in the list of members has details of its name, type and amount of 
  Memory required if an array. 
*/

RecordDecl                      (.  string name, name1; TastierType type; List<RecordDeclMember> recDeclVars = new List<RecordDeclMember>();
                                    int arrDecl = -1, arrLen = 1; List<int> lengths = new List<int>(); Scope currentScope = openScopes.Peek();
                                .)
= "record"                      
  Ident<out name>               
                                  /* 
                                     Push a new Record Symbol on to the global scope.
                                     Used to create the ‘header file’
                                  */
                                (.  currentScope.Push(new Symbol(name, (int)TastierKind.Record, (int)TastierType.Undefined, openScopes.Count-1, nextFreeAddress));
                                    nextFreeAddress = nextFreeAddress + 1;
                                .)
  '{' 
     Type<out type>           
     Ident<out name1>           /* 
                                  A record decl. must have at least one member
                                  If member is an array - add it to the list of arrays
                                  Add member to the list of members for this record in the list of record declarations
                                  RecordDeclMember.Item3 will hold the length if member is array or -1 if not array
                                */
        { '['number             (.  int n = Convert.ToInt32(t.val);
                                    lengths.Add(n); arrLen = arrLen * n; arrDecl = arrLen;
                                .)
          ']' }
                                (.  if (arrDecl != -1) arraysList.Add(new ArrayDecl(name1, lengths));
                                    recDeclVars.Add(new RecordDeclMember(name1, (int)type, arrDecl));
                                    arrDecl = -1; arrLen = 1; lengths = new List<int>();
                                .)

        { ',' Ident<out name1>        
            { '['number         (.  int n = Convert.ToInt32(t.val);
                                    lengths.Add(n); arrLen = arrLen * n; arrDecl = arrLen;
                                .)
              ']' }
                                (.  if (arrDecl != -1) arraysList.Add(new ArrayDecl(name1, lengths));
                                    recDeclVars.Add(new RecordDeclMember(name1, (int)type, arrDecl));
                                    arrDecl = -1; arrLen = 1; lengths = new List<int>();
                                .)
        } ';'

      { Type<out type>
        Ident<out name1>          
        { '['number             (.  int n = Convert.ToInt32(t.val);
                                    lengths.Add(n); arrLen = arrLen * n; arrDecl = arrLen;
                                .)
          ']' }
                                (.  if (arrDecl != -1) arraysList.Add(new ArrayDecl(name1, lengths));
                                    recDeclVars.Add(new RecordDeclMember(name1, (int)type, arrDecl));
                                    arrDecl = -1; arrLen = 1; lengths = new List<int>();
                                .)

        { ',' Ident<out name1>        
            { '['number         (.  int n = Convert.ToInt32(t.val);
                                    lengths.Add(n); arrLen = arrLen * n; arrDecl = arrLen;
                                .)
              ']' }
                                (.  if (arrDecl != -1) arraysList.Add(new ArrayDecl(name1, lengths));
                                    recDeclVars.Add(new RecordDeclMember(name1, (int)type, arrDecl));
                                    arrDecl = -1; arrLen = 1; lengths = new List<int>();
                                .)
        }';'
      } 
                                (.  recDeclsList.Add(new RecordDecl(name, recDeclVars)); .)
        '}' ';' .

/*------------------------------------------------------------------------*/
/*
  RecordInst is entered when a single instance of a declared record is 
  found in a program.
  e.g. record aRecord singleRec; (1)

  RecordInst takes a ParameterisedProc pp as a parameter. This will have a 
  value if this function has been called due to a a record instance being 
  declared as a parameter in a Procedure Declaration. 
  e.g. myProcedure(record aRecord singleRec){ (2)
        ...
       }
  Otherwise, if RecordInst has been called from VarDecl because pattern (1)
  was recognised (i.e. instance not a parameter of a procedure declaration),
  pp will be null. We must pass pp to this function if a record instance is 
  a parameter for a procedure so that we can add its symbol to the list of
  parameters for the procedure in question.

*/

RecordInst
<ParameterisedProc pp>          (.  string name, name1; Scope currentScope = openScopes.Peek(); bool recordValid = false; 
                                    List<RecordDeclMember> recDeclVars = new List<RecordDeclMember>();
                                .)
= "record"                      
  Ident<out name>
  Ident<out name1>              (.  /* Check that this instance refers to a declared record. */
                                    foreach (RecordDecl r in recDeclsList) {
                                      if((r.Item1).Equals(name)){
                                        recordValid = true; recDeclVars = r.Item2;
                                        break;
                                      }
                                    }
                                    /*
                                       Push this instance record symbol on stack. Add this instance name and the name 
                                       of the record to which it is an instance of to a list of record instances. The
                                       reason for the list of record instances is that if a parameter of a procedure is
                                       set to take a record, we must make sure that when we pass a record as an attribute,
                                       the passing and receiving records are instances of the same record declaration!
                                    */
                                    if (recordValid == true) {
                                      Symbol sym = new Symbol(name1, (int)TastierKind.Record, (int)TastierType.Undefined, 0, nextFreeAddress);
                                      currentScope.Push(sym);
                                      nextFreeAddress = nextFreeAddress + 1;
                                      recInstsList.Add(new RecordInstance(name1, name));

                                      if (pp != null) pp.Item2.Add(sym); //Record Instance is a Procedure Parameter
                                      /* 
                                         Go through the list of members and for each, create a new symbol of this record 
                                         instance. Allocate memory for each member, lengthOfArray addresses if array 
                                         member. 
                                      */
                                      foreach (RecordDeclMember r in recDeclVars) {
                                        if (r.Item3 == -1) {
                                          /* 
                                            Name of an instance member of the form (instance name + '.' + member name) so when we want to
                                            access this member, it is easily found e.g. myRecord.i := 7.
                                          */
                                          currentScope.Push(new Symbol((name1 + '.' + r.Item1), (int)TastierKind.Var, r.Item2, 0, nextFreeAddress));
                                          nextFreeAddress = nextFreeAddress + 1;

                                        } else { // array member: allocate space for each address in array
                                          currentScope.Push(new Symbol((name1 + '.' + r.Item1), (int)TastierKind.ArrayVar, r.Item2, 0, nextFreeAddress));
                                          nextFreeAddress = nextFreeAddress + r.Item3; //array length

                                          List<int> templengths = new List<int>();
                                          foreach (ArrayDecl a in arraysList) {
                                            if((a.Item1).Equals(r.Item1)){ templengths = a.Item2; break; }
                                          }
                                          arraysList.Add(new ArrayDecl((name1 + '.' + r.Item1), templengths));
                                        } 
                                      }
                                    } else { //attempt to make an instance of a record that has not been declared (does not exist!)
                                      SemErr ("cannot instantiate " + name1 + " on non resolved record variable " + name); } 
                                .)
.

/*------------------------------------------------------------------------*/

VarDecl
                                (.  string name; TastierType type; Scope currentScope = openScopes.Peek(); int arrLen = 1;
                                    bool arrDecl = false; List<int> lengths = new List<int>();
                                .)
= Type<out type>
  Ident<out name>               /*
                                    A VarDecl can be of the form e.g.'int a;', 'string s;' or
                                    e.g.'int a[2][3][2]' if an array. The length of an array is
                                    calculated by multiplying the length of the dimensions.
                                    Memory must be kept free for each address in an array declaration.
                                */             
  { '['number                   (.  int n = Convert.ToInt32(t.val);
                                    lengths.Add(n); arrLen = arrLen * n; arrDecl = true;
                                .)
    ']' }             
                                (.  
                                    if (arrDecl == true) {
                                      currentScope.Push(new Symbol(name, (int)TastierKind.ArrayVar, (int)type, 0, nextFreeAddress));
                                      arraysList.Add(new ArrayDecl(name, lengths));

                                      nextFreeAddress = nextFreeAddress + arrLen;

                                      arrDecl = false; lengths = new List<int>(); arrLen = 1;
                                    } else if (openScopes.Count == 1 || type == TastierType.String) {
                                      currentScope.Push(new Symbol(name, (int)TastierKind.Var, (int)type, 0, nextFreeAddress));
                                      nextFreeAddress = nextFreeAddress + 1;
                                    } else {
                                      currentScope.Push(new Symbol(name, (int)TastierKind.Var, (int)type, openScopes.Count-1, currentScope.Count(s => s.Item2 == (int)TastierKind.Var)));
                                    }
                                .)
      { ',' 
        Ident<out name>       
        { '['number             (.  int n = Convert.ToInt32(t.val);
                                    lengths.Add(n);arrLen = arrLen * n; arrDecl = true;
                                .)
          ']' }             
                                (.
                                    if (arrDecl == true) {
                                      currentScope.Push(new Symbol(name, (int)TastierKind.ArrayVar, (int)type, 0, nextFreeAddress));
                                      arraysList.Add(new ArrayDecl(name, lengths));

                                      nextFreeAddress = nextFreeAddress + arrLen;

                                      arrDecl = false; lengths = new List<int>(); arrLen = 1;
                                    } else if (openScopes.Count == 1 || type == TastierType.String) {
                                      currentScope.Push(new Symbol(name, (int)TastierKind.Var, (int)type, 0, nextFreeAddress));
                                      nextFreeAddress = nextFreeAddress + 1;
                                    } else {
                                      currentScope.Push(new Symbol(name, (int)TastierKind.Var, (int)type, openScopes.Count-1, currentScope.Count(s => s.Item2 == (int)TastierKind.Var)));
                                    }
                                .)
      } ';'                          
  | RecordInst<null> ';' .  //record instance is not a parameter of a procedure

/*------------------------------------------------------------------------*/
/*
  ParamDecl is called during a Procedure Declaration, each time we come
  across a parameter as part of the proc. decl.

  The first time we call this function i.e. when we come across the first
  parameter in a procedure declaration, we create a 'ParameterisedProc' tuple 
  that will represent the procedure beig declared and its parameters.

  Item1 is the name of a procedure that has parameters, Item2 is a list of 
  the symbols of these parameters. We keep record of this so that when a 
  call is made to a procedure, we can do all the necessary checks on attributes 
  being passed compared to parameters that are receiving i.e. same dimensions 
  & length if array, same type, same record declaration.

  For each parameter in the procedure declaration, we push the symbol on to the
  procedure scope, in the same manner as VarDecl or RecordInst. The 
  difference here is that we also store the symbol in a list of parameters, and 
  together with the name of the procedure, enter this into a list of
  Parameterised Procedures.
*/
ParamDecl<string ProcedureName>
                                (.  string name; TastierType type; Scope currentScope = openScopes.Peek(); int arrLen = 1;
                                    bool arrDecl = false; List<int> lengths = new List<int>(); ParameterisedProc pp = null;

                                    foreach (ParameterisedProc p in paramProcsList) {
                                      if((p.Item1).Equals(ProcedureName)) { pp = p; break; }
                                    }

                                    if (pp == null) {
                                      List<Symbol> temp = new List<Symbol>();
                                      pp = new ParameterisedProc(ProcedureName, temp);
                                      paramProcsList.Add(pp);
                                    }
                                .)
= Type<out type>
  Ident<out name>                            
  { '['number                   (.  int n = Convert.ToInt32(t.val);
                                    lengths.Add(n); arrLen = arrLen * n; arrDecl = true;
                                .)
    ']' }             
                                (.  
                                    if (arrDecl == true) {
                                      Symbol sym = new Symbol(name, (int)TastierKind.ArrayVar, (int)type, 0, nextFreeAddress);
                                      currentScope.Push(sym);
                                      arraysList.Add(new ArrayDecl(name, lengths));
                                      pp.Item2.Add(sym);

                                      nextFreeAddress = nextFreeAddress + arrLen;

                                    } else {
                                      Symbol sym = new Symbol(name, (int)TastierKind.Var, (int)type, 0, nextFreeAddress);
                                      currentScope.Push(sym);
                                      nextFreeAddress = nextFreeAddress + 1;
                                      pp.Item2.Add(sym);
                                    }
                                .)
  | RecordInst<pp>  //Record instance as parameter e.g. myProcedure(record aRecord singleRec){ ... }
                    //pp is the ParameterisedProc tuple representing the procedure with parameters in question
.

END Tastier.